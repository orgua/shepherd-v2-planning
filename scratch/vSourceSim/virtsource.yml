virtsource:
  # crosscheck against check_and_complete() in virt_source_data.py to see:
  # - what is required
  # - the limits and default values
  # NOTE: input can be also float (ie. 2.3e-4), there is no proper int-formatting (like in py 1_000_000)

  # TODO: find a way to process direct, boost, boost + buck, future: IV-Curves as input for same regulator
  converter_mode: 3 # activate features: bit0=boost (currently not evaluated), bit1=buck
  interval_startup_disabled_drain_ms: 1

  # Direct Reg
  C_output_uF: 1   # final (always last) stage to catch current spikes of target

  # Boost Reg, ie. BQ25504
  V_input_boost_threshold_mV: 130 # min input-voltage for the boost converter to work
  C_storage_uF: 22
  V_storage_init_mV: 3000 # allow a proper / fast startup
  V_storage_max_mV:  3600 # -> boost shuts off
  I_storage_leak_nA: 9
  V_storage_enable_threshold_mV: 2600 # -> target gets connected (hysteresis-combo with next value)
  V_storage_disable_threshold_mV: 2300 # -> target gets disconnected
  interval_check_thresholds_ms: 64.0  # some BQs check every 64 ms if output should be disconnected
  LUT_input_efficiency: [
    [  0.001, 0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 0.99, 1.0 ],
    [  0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50 ],
    [  0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50 ],
    [  0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50 ],
    [  0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50 ],
    [  0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50 ],
    [  0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50 ],
    [  0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50 ],
    [  0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50 ],
    [  0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50 ],
    [  0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50 ],
    [  0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50 ],
  ]
  # array[12][12] depending on inp_voltage, inp_current, (cap voltage), TODO: 50% for now
  # NOTE: these will be reduced to internal 8bit for now, 1.0 represented by 255
  # TODO: LUT could be accessed by highest bit-position of "1" in depending index/input. 12 bit should suffice for 8192 int
  V_pwr_good_enable_threshold_mV: 2800 # target is informed by pwr-good output-pin (hysteresis)
  V_pwr_good_disable_threshold_mV: 2400
  immediate_pwr_good_signal: 1  # 1: emulate schmitt-trigger, 0: stay in interval for checking thresholds

  # Buck Boost, ie. BQ25570
  V_output_mV: 2000
  #LUT_output_efficiency[12]: [0.80, 0.80, 0.80, 0.80, 0.80, 0.80, 0.80, 0.80, 0.80, 0.80, 0.80, 0.80]
  LUT_output_efficiency: [0.0, 0.001, 0.10, 0.20, 0.30, 0.40, 0.50, 0.70, 0.80, 0.90, 0.999, 1.00]
  # array[12] depending on output_current, currently set to ~ 80 %

  # TODO: test all 3 separate regulators, can be checked against returning voltage
